const TelegramBot = require('node-telegram-bot-api');
const CONFIG = require('../config');
const logger = require('../utils/logger');
const storage = require('../utils/storage');

class TelegramService {
    constructor() {
        this.recreioBot = null;
        this.banguBot = null;
    }

    start() {
        try {
            this.recreioBot = new TelegramBot(CONFIG.telegram.recreioToken, { polling: true });
            this.banguBot = new TelegramBot(CONFIG.telegram.banguToken, { polling: true });

            logger.info('🤖 Bots do Telegram (Recreio e Bangu) iniciados com sucesso.');

            this.setupHandlers();
        } catch (error) {
            logger.error("❌ Falha ao iniciar os bots do Telegram:", error.message);
        }
    }

    setupHandlers() {
        this.recreioBot.on('message', (msg) => {
            if (msg.text && msg.text.startsWith('/')) {
                this.handleManagement(this.recreioBot, msg, 'recreio');
            }
        });

        this.banguBot.on('message', (msg) => {
            if (msg.text && msg.text.startsWith('/')) {
                this.handleManagement(this.banguBot, msg, 'bangu');
            }
        });
    }

    parseDate(dateStr) {
        const parts = dateStr.split('/');
        if (parts.length !== 2) return null;
        const day = parts[0].padStart(2, '0');
        const month = parts[1].padStart(2, '0');
        const year = new Date().getFullYear();
        return `${year}-${month}-${day}`;
    }

    async handleManagement(bot, msg, botType) {
        const chatId = msg.chat.id;
        const text = msg.text;
        const [command, dateStr, timeStr, ...nameParts] = text.split(' ');

        const filePath = botType === 'recreio' ? CONFIG.jsonFilePaths.recreio : CONFIG.jsonFilePaths.bangu;
        
        if (!command || !dateStr || !timeStr || nameParts.length === 0 && command !== '/status') {
            bot.sendMessage(chatId, "Formato inválido. Use:\n/add DD/MM HH:mm Nome\n/cancel DD/MM HH:mm Nome\n/status DD/MM [HH:mm]");
            return;
        }

        const agenda = await storage.readAgenda(filePath);
        const dateISO = this.parseDate(dateStr);
        const timeKey = timeStr;

        if (!dateISO) {
            bot.sendMessage(chatId, "Data inválida. Use o formato DD/MM.");
            return;
        }
        
        if (!agenda[dateISO]) agenda[dateISO] = {};
        if (!agenda[dateISO][timeKey]) agenda[dateISO][timeKey] = [];

        const name = nameParts.join(' ');

        switch (command) {
            case '/add':
                await this.handleAdd(bot, chatId, agenda, dateISO, timeKey, name, filePath, botType);
                break;

            case '/cancel':
                await this.handleCancel(bot, chatId, agenda, dateISO, timeKey, name, filePath);
                break;

            case '/status':
                await this.handleStatus(bot, chatId, agenda, dateISO, nameParts[0], botType);
                break;
        }
    }

    async handleAdd(bot, chatId, agenda, dateISO, timeKey, name, filePath, botType) {
        const [mainName, companionName] = name.includes('+') ? name.split('+').map(n => n.trim()) : [name, null];
        const spotsNeeded = companionName ? 2 : 1;
        const currentSpots = agenda[dateISO][timeKey].length;

        if (botType === 'recreio' && (currentSpots + spotsNeeded > 2)) {
            bot.sendMessage(chatId, `❌ Erro! Não há vagas suficientes. Vagas ocupadas: ${currentSpots}/2.`);
            return;
        }

        agenda[dateISO][timeKey].push({ name: mainName });
        if (companionName) {
            agenda[dateISO][timeKey].push({ name: `${companionName} (Acompanhante)` });
        }
        
        await storage.writeAgenda(filePath, agenda);
        bot.sendMessage(chatId, `✅ Agendamento adicionado para ${mainName}${companionName ? ' + ' + companionName : ''} em ${dateISO.split('-').slice(1,3).reverse().join('/')} às ${timeKey}.`);
    }

    async handleCancel(bot, chatId, agenda, dateISO, timeKey, name, filePath) {
        const initialLength = agenda[dateISO][timeKey].length;
        agenda[dateISO][timeKey] = agenda[dateISO][timeKey].filter(p => !p.name.toLowerCase().includes(name.toLowerCase()));
        
        if (agenda[dateISO][timeKey].length < initialLength) {
            await storage.writeAgenda(filePath, agenda);
            bot.sendMessage(chatId, `✅ Agendamento para "${name}" cancelado com sucesso.`);
        } else {
            bot.sendMessage(chatId, `⚠️ Aluno "${name}" não encontrado nesse horário.`);
        }
    }

    async handleStatus(bot, chatId, agenda, dateISO, timeParam, botType) {
        let statusTimeKey = timeParam ? timeParam.replace(':', '') : null;
        let response = `Status para ${dateISO.split('-').slice(1,3).reverse().join('/')} (${botType}):\n\n`;

        const dayAgenda = agenda[dateISO];
        if (!dayAgenda || Object.keys(dayAgenda).length === 0) {
            bot.sendMessage(chatId, `Nenhum agendamento para esta data.`);
            return;
        }

        for(const time in dayAgenda){
            if(statusTimeKey && time !== statusTimeKey) continue;

            const spots = dayAgenda[time];
            response += `*Horário ${time.slice(0,2)}:${time.slice(2)}:*\n`;
            response += `Vagas: ${spots.length}/2\n`;
            if(spots.length > 0) {
                spots.forEach(p => {
                    response += `- ${p.name}\n`;
                });
            }
            response += `\n`;
        }
        bot.sendMessage(chatId, response, {parse_mode: 'Markdown'});
    }
}

module.exports = TelegramService;